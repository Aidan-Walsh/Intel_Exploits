# Intel_Exploits
A wide range of different exploits that use different techniques on intel architecture. These techniques include the following: string formatting, sigreturn oriented programming, and stack pivots. Some of these exploits are very short, some are long, some were quite easy to write, and others took a lot of work. 

# Exploiting
These exploits are all written in python using the pwn library - a very helpful library. The goal of these exploits was to pop shells, or run code that lets me run a shell. None of these executables were created by me, I just looked for vulnerable executables written by others. You can attempt to run these executables on your machine and see how they work with the following steps: 
1. Download the executable and its corresponding python exploit. 
2. Run the python file "file.py" (it will run the executable)
    - "python3 file.py"
    - you should now be in a shell! So you can type any commands like "whoami" 
    - it may take a second or two (or longer) to pop the shell depending on the complexity of the exploit
    - if your screen totally changes then you may be in gdb (which is supposed to happen for the exploit to work), if this happens, type "exit" then ENTER

The following explanations are very surface level. To see how they exactly work, check out the python files that provide a little more detail. 

# b0verflow
This executable is exploited by "flow.py". This exploit utilizes a stack pivot and return oriented programming (ROP). So, the program receives input, has an overflow issue and so we overwrite the return address to an instruction in memory that subtracts the stack pointer. This lets us execute an instruction that lets us execute instructions on the stack, that we have planted with our input. Thus, we are able to run our instructions on the stack that tell the program to pop a shell. 

# mary_morton
This executable is exploited by "mary.py". This attack uses string formatting, which reveals a stack canary. With the stack canary, we are then able to overflow the stack. We have an address of a function that will run a shell for us, so we just overwrite the return address with this function.

# onewrite
This executable is exploited by "one.py". This attack does a lot and so this explanation is a bit of a simplification. This executable is dynamically linked with libc, so we take advantage of this. When our main function exits, it calls some libc exit function, which then calls an array which has a bunch of other exit functions. So, we overwrite this libc exit function to return to itself when it is done, and we overwrite the array contents to a function that lets us overwrite any address with any data. With this, we have an infinite loop of the overwriting function we need. With this overwriting present, we are able to get the leaks and overwrites we need to eventually execute a rop chain we store in memory by changing the stack pointer. With a rop chain and manipulation of the stack pointer, we can pop a shell.

# svc
This executable is exploited by "scv.py". This starts off by leaking the canary by just sending enough bytes to be printed out. With the canary, we can then overflow by calling the puts() function on itself to reveal its location in the libc library. With this location, and offsets in the libc library, we can then calculate the location of system() and of "/bin/sh". With these locations and the right gadgets, we overwrite return addresses to execute the shell for us. 

# server
This executable is exploited by "server.py". This exploit leaks the libc address of printf by using the got and plt addresses of printf(). With this, we can use the offsets to find the addresses of system and "/bin/sh". After this leak, the function would exit, so we overwrite the function to return to itself, so that we may send the payload. This payload, since we are working with a 32 bit executable does not require us to use registers when calling a function - only the stack. Thus, we have no rop chain and just send the addresses of "/bin/sh" and system(). 

# small_boi
This exectuable is exploited by "small.py". Its name serves it well. This just involved a sig return where we get the function to return to a sigreturn, and set up the registers to make a syscall with "/bin/sh". 

# story time
This executable was exploited by "story.py". This involves leaking the address of write in libc by using its got and plt addresses. We leaked the address and overwrote main to return to itself so that we may continue exploiting. With the leaked address, we used offsets to find the locations of system and "/bin/sh". With these and a rop chain, overwrote the return addresses to pop a shell. 

# stupidrop
This executable is exploited by "stupid.py". With no libc and very little, we had to write "/bin/sh" to memory. We did this by finding the location of gets() so that we can write to memory in bss and adjusted our rax register to the correct value by calling alarm(), then alarm() again. Alarm returns the amount of time left if another alarm is called, so this let us manipulate the rax register. So, our payload overwrote the return address to call gets(), then a couple of alarms, then a syscall to call a sigreturn. With a sigreturn and "/bin/sh" in memory, we can pop a shell. 

# syscaller
This executable is exploited by "sys.py". When reverse engineering this binary, the main program does a lot of popping into some registers which is very helpful. So, we pop values into the registers to make a sigreturn call. With the sigreturn and the frame, we set up an mprotect call which makes a certain segment of memory writable (it was already executable). We also adjust the stack pointer and rsi register so that when we write to memory when the function reads again (we adjusted the instruction pointer to go back to pop into the registers again), we write to the writable part of memory. With that, we return ourselves to the popping instructions which let us write to writable memory, pop everything we need into the registers again and make a system() call with "/bin/sh" in memory. 
